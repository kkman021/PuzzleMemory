<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>æ‹¼åœ–è¨˜æ†¶éŠæˆ²</title>
<style>
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
  top: 0;
  left: 0;
  touch-action: none;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: none;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* ===== ä¸Šå‚³ç•«é¢ ===== */
#screen-upload {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  padding: 20px;
  gap: 24px;
}

.game-title {
  font-size: 28px;
  font-weight: 800;
  letter-spacing: 2px;
  background: linear-gradient(90deg, #f7971e, #ffd200);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.upload-zone {
  width: 90%;
  max-width: 320px;
  aspect-ratio: 1;
  border: 3px dashed rgba(255,255,255,0.3);
  border-radius: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.upload-zone.has-image {
  border-color: #ffd200;
}

.upload-zone:active {
  transform: scale(0.97);
}

.upload-zone .icon {
  font-size: 48px;
  opacity: 0.6;
}

.upload-zone .text {
  font-size: 16px;
  opacity: 0.6;
}

.upload-zone .preview-img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 17px;
}

#file-input {
  display: none;
}

.difficulty-section {
  text-align: center;
}

.difficulty-section label {
  font-size: 14px;
  opacity: 0.7;
  display: block;
  margin-bottom: 10px;
}

.difficulty-btns {
  display: flex;
  gap: 12px;
}

.diff-btn {
  padding: 10px 22px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  background: transparent;
  color: #fff;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.diff-btn.active {
  border-color: #ffd200;
  background: rgba(255, 210, 0, 0.15);
  color: #ffd200;
}

.diff-btn:active {
  transform: scale(0.95);
}

.btn-start {
  padding: 14px 48px;
  border: none;
  border-radius: 14px;
  background: linear-gradient(135deg, #f7971e, #ffd200);
  color: #1a1a2e;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  opacity: 0.4;
  pointer-events: none;
}

.btn-start.ready {
  opacity: 1;
  pointer-events: auto;
}

.btn-start:active {
  transform: scale(0.95);
}

/* ===== éŠæˆ²ç•«é¢ ===== */
#screen-game {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
  height: 100%;
  padding: 12px;
  gap: 10px;
}

.top-bar {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 0;
}

.timer {
  font-size: 22px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: #ffd200;
}

.top-actions {
  display: flex;
  gap: 8px;
}

.btn-sm {
  padding: 8px 14px;
  border: 1.5px solid rgba(255,255,255,0.3);
  border-radius: 10px;
  background: rgba(255,255,255,0.08);
  color: #fff;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-sm:active {
  transform: scale(0.93);
  background: rgba(255,255,255,0.15);
}

.puzzle-container {
  flex: 1;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.puzzle-board {
  display: grid;
  gap: 2px;
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  padding: 4px;
  position: relative;
}

.puzzle-piece {
  border-radius: 6px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
  position: relative;
}

.puzzle-piece canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.puzzle-piece.selected {
  transform: scale(1.05);
  box-shadow: 0 0 0 3px #ffd200, 0 4px 20px rgba(255,210,0,0.4);
  z-index: 10;
}

.puzzle-piece.correct {
  opacity: 1;
}

.puzzle-piece.correct::after {
  content: '';
  position: absolute;
  inset: 0;
  border: 2px solid rgba(76, 217, 100, 0.6);
  border-radius: 6px;
  pointer-events: none;
}

.puzzle-piece.dragging {
  opacity: 0.5;
  transform: scale(0.9);
}

.puzzle-piece.drag-over {
  box-shadow: 0 0 0 3px #00bcd4, 0 4px 15px rgba(0,188,212,0.3);
}

.hint-text {
  font-size: 12px;
  opacity: 0.4;
  text-align: center;
  padding: 4px;
}

/* ===== åŸåœ–é è¦½è¦†è“‹å±¤ ===== */
.preview-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 100;
  background: rgba(0,0,0,0.85);
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 16px;
  padding: 20px;
}

.preview-overlay.show {
  display: flex;
}

.preview-overlay img {
  max-width: 90%;
  max-height: 70vh;
  border-radius: 12px;
  object-fit: contain;
}

.preview-overlay .close-hint {
  font-size: 14px;
  opacity: 0.6;
}

/* ===== å®Œæˆç•«é¢ ===== */
.complete-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 200;
  background: rgba(15, 12, 41, 0.95);
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 20px;
  padding: 20px;
}

.complete-overlay.show {
  display: flex;
}

.complete-title {
  font-size: 36px;
  font-weight: 800;
  background: linear-gradient(90deg, #f7971e, #ffd200);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.complete-stats {
  text-align: center;
  font-size: 18px;
  line-height: 2;
  opacity: 0.8;
}

.complete-actions {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn-complete {
  padding: 12px 28px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  background: transparent;
  color: #fff;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-complete:active {
  transform: scale(0.95);
}

.btn-complete.primary {
  border-color: #ffd200;
  background: rgba(255, 210, 0, 0.15);
  color: #ffd200;
}

.complete-image {
  max-width: 60%;
  max-height: 30vh;
  border-radius: 12px;
  object-fit: contain;
}

/* ===== å‹•ç•« ===== */
@keyframes pop-in {
  0% { transform: scale(0.5); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes swap-pop {
  0% { transform: scale(0.85); }
  50% { transform: scale(1.08); }
  100% { transform: scale(1); }
}

.puzzle-piece.initial-anim {
  animation: pop-in 0.3s ease-out both;
}

.puzzle-piece.swap-anim {
  animation: swap-pop 0.3s ease-out both;
}
</style>
</head>
<body>

<!-- ===== ä¸Šå‚³ç•«é¢ ===== -->
<div id="screen-upload">
  <div class="game-title">æ‹¼åœ–è¨˜æ†¶éŠæˆ²</div>

  <div class="upload-zone" id="upload-zone">
    <div class="icon" id="upload-icon">ğŸ“</div>
    <div class="text" id="upload-text">é»æ“Šé¸æ“‡åœ–ç‰‡</div>
  </div>
  <input type="file" id="file-input" accept="image/*">

  <div class="difficulty-section">
    <label>é¸æ“‡é›£åº¦</label>
    <div class="difficulty-btns">
      <button class="diff-btn active" data-grid="3">3Ã—3</button>
      <button class="diff-btn" data-grid="4">4Ã—4</button>
      <button class="diff-btn" data-grid="5">5Ã—5</button>
    </div>
  </div>

  <button class="btn-start" id="btn-start">é–‹å§‹éŠæˆ²</button>
</div>

<!-- ===== éŠæˆ²ç•«é¢ ===== -->
<div id="screen-game">
  <div class="top-bar">
    <div class="timer" id="timer">00:00</div>
    <div class="top-actions">
      <button class="btn-sm" id="btn-preview">é¡¯ç¤ºåŸåœ–</button>
      <button class="btn-sm" id="btn-restart">å›é¦–é </button>
    </div>
  </div>

  <div class="puzzle-container">
    <div class="puzzle-board" id="puzzle-board"></div>
  </div>

  <div class="hint-text">æ‹–æ‹‰äº¤æ› æˆ– é»æ“Šå…©å¡Šäº¤æ›ä½ç½®</div>
</div>

<!-- ===== åŸåœ–é è¦½ ===== -->
<div class="preview-overlay" id="preview-overlay">
  <img id="preview-full" src="" alt="åŸåœ–">
  <div class="close-hint">é»æ“Šä»»æ„è™•é—œé–‰</div>
</div>

<!-- ===== å®Œæˆç•«é¢ ===== -->
<div class="complete-overlay" id="complete-overlay">
  <div class="complete-title">æ­å–œå®Œæˆï¼</div>
  <img class="complete-image" id="complete-image" src="" alt="å®Œæˆåœ–">
  <div class="complete-stats" id="complete-stats"></div>
  <div class="complete-actions">
    <button class="btn-complete primary" id="btn-play-again">å†ç©ä¸€æ¬¡</button>
    <button class="btn-complete" id="btn-new-image">æ›å¼µåœ–ç‰‡</button>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ===== é˜²æ­¢æ‰€æœ‰å¹²æ“¾æ‰‹å‹¢ =====
  document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend', e => e.preventDefault(), { passive: false });

  // ç¦æ­¢é›™æŒ‡ç¸®æ”¾
  document.addEventListener('touchmove', function(e) {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });

  // ç¦æ­¢é›™æ“Šç¸®æ”¾
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function(e) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, { passive: false });

  // ç¦æ­¢å³éµé¸å–®
  document.addEventListener('contextmenu', e => e.preventDefault());

  // ç¦æ­¢æ»‘å‹•å›ä¸Šä¸€é  (overscroll navigation)
  document.body.addEventListener('touchmove', function(e) {
    if (!e.target.closest('.puzzle-board')) {
      e.preventDefault();
    }
  }, { passive: false });

  // ===== ç‹€æ…‹ =====
  let uploadedImage = null;   // Image ç‰©ä»¶
  let imageDataURL = null;    // base64 data URL
  let gridSize = 3;
  let pieces = [];            // { index, correctIndex, canvas }
  let selectedIndex = null;
  let timerInterval = null;
  let seconds = 0;
  let timerStarted = false;
  let gameActive = false;
  let moveCount = 0;

  // ===== DOM =====
  const screenUpload = document.getElementById('screen-upload');
  const screenGame = document.getElementById('screen-game');
  const uploadZone = document.getElementById('upload-zone');
  const fileInput = document.getElementById('file-input');
  const uploadIcon = document.getElementById('upload-icon');
  const uploadText = document.getElementById('upload-text');
  const btnStart = document.getElementById('btn-start');
  const diffBtns = document.querySelectorAll('.diff-btn');
  const puzzleBoard = document.getElementById('puzzle-board');
  const timerEl = document.getElementById('timer');
  const btnPreview = document.getElementById('btn-preview');
  const btnRestart = document.getElementById('btn-restart');
  const previewOverlay = document.getElementById('preview-overlay');
  const previewFull = document.getElementById('preview-full');
  const completeOverlay = document.getElementById('complete-overlay');
  const completeImage = document.getElementById('complete-image');
  const completeStats = document.getElementById('complete-stats');
  const btnPlayAgain = document.getElementById('btn-play-again');
  const btnNewImage = document.getElementById('btn-new-image');

  // ===== ä¸Šå‚³å€ =====
  uploadZone.addEventListener('click', () => fileInput.click());

  fileInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) handleImageFile(file);
  });

  function handleImageFile(file) {
    if (!file.type.startsWith('image/')) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      imageDataURL = e.target.result;
      const img = new Image();
      img.onload = function() {
        uploadedImage = img;

        // é¡¯ç¤ºé è¦½
        uploadZone.classList.add('has-image');
        const existing = uploadZone.querySelector('.preview-img');
        if (existing) existing.remove();
        const preview = document.createElement('img');
        preview.className = 'preview-img';
        preview.src = imageDataURL;
        uploadZone.appendChild(preview);
        uploadIcon.style.display = 'none';
        uploadText.style.display = 'none';

        btnStart.classList.add('ready');
      };
      img.src = imageDataURL;
    };
    reader.readAsDataURL(file);
  }

  // ===== é›£åº¦é¸æ“‡ =====
  diffBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      diffBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      gridSize = parseInt(this.dataset.grid);
    });
  });

  // ===== é–‹å§‹éŠæˆ² =====
  btnStart.addEventListener('click', startGame);

  function startGame() {
    if (!uploadedImage) return;

    screenUpload.style.display = 'none';
    screenGame.style.display = 'flex';

    resetTimer();
    gameActive = true;
    moveCount = 0;
    selectedIndex = null;

    buildPuzzle();
  }

  // ===== å»ºç«‹æ‹¼åœ– =====
  function buildPuzzle() {
    puzzleBoard.innerHTML = '';

    const containerEl = document.querySelector('.puzzle-container');
    const maxW = containerEl.clientWidth - 8;
    const maxH = containerEl.clientHeight - 8;
    const boardSize = Math.min(maxW, maxH);
    const pieceSize = Math.floor((boardSize - (gridSize - 1) * 2 - 8) / gridSize);
    const totalSize = pieceSize * gridSize + (gridSize - 1) * 2 + 8;

    puzzleBoard.style.gridTemplateColumns = `repeat(${gridSize}, ${pieceSize}px)`;
    puzzleBoard.style.gridTemplateRows = `repeat(${gridSize}, ${pieceSize}px)`;
    puzzleBoard.style.width = totalSize + 'px';
    puzzleBoard.style.height = totalSize + 'px';

    // è£å‰ªåœ–ç‰‡ç‚ºæ­£æ–¹å½¢
    const img = uploadedImage;
    const cropSize = Math.min(img.width, img.height);
    const sx = (img.width - cropSize) / 2;
    const sy = (img.height - cropSize) / 2;
    const srcPieceSize = cropSize / gridSize;

    // å»ºç«‹ç¢ç‰‡
    pieces = [];
    const total = gridSize * gridSize;

    for (let i = 0; i < total; i++) {
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;

      const canvas = document.createElement('canvas');
      canvas.width = pieceSize * 2;  // é«˜è§£æåº¦
      canvas.height = pieceSize * 2;
      canvas.style.width = pieceSize + 'px';
      canvas.style.height = pieceSize + 'px';

      const ctx = canvas.getContext('2d');
      ctx.drawImage(
        img,
        sx + col * srcPieceSize, sy + row * srcPieceSize,
        srcPieceSize, srcPieceSize,
        0, 0,
        pieceSize * 2, pieceSize * 2
      );

      pieces.push({ correctIndex: i, canvas: canvas });
    }

    // æ‰“äº‚ï¼ˆFisher-Yatesï¼‰ï¼Œç¢ºä¿ä¸åœ¨åŸä½
    let shuffled;
    do {
      shuffled = [...pieces];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
    } while (shuffled.some((p, i) => p.correctIndex === i));

    pieces = shuffled;

    renderBoard();
  }

  // ===== æ¸²æŸ“æ‹¼åœ– =====
  function renderBoard() {
    puzzleBoard.innerHTML = '';

    pieces.forEach((piece, index) => {
      const div = createPieceDiv(piece, index);
      div.classList.add('initial-anim');
      div.style.animationDelay = (index * 0.03) + 's';
      puzzleBoard.appendChild(div);
    });
  }

  function createPieceDiv(piece, index) {
    const div = document.createElement('div');
    div.className = 'puzzle-piece';
    div.dataset.index = index;
    div.appendChild(piece.canvas);

    if (piece.correctIndex === index) {
      div.classList.add('correct');
    }

    // æ‹–æ‹‰äº‹ä»¶ (æ¡Œé¢)
    div.draggable = true;
    div.addEventListener('dragstart', onDragStart);
    div.addEventListener('dragover', onDragOver);
    div.addEventListener('dragenter', onDragEnter);
    div.addEventListener('dragleave', onDragLeave);
    div.addEventListener('drop', onDrop);
    div.addEventListener('dragend', onDragEnd);

    // é»æ“Šäº‹ä»¶
    div.addEventListener('click', () => onPieceClick(index));

    // è§¸æ§æ‹–æ‹‰
    div.addEventListener('touchstart', onTouchStart, { passive: false });
    div.addEventListener('touchmove', onTouchMove, { passive: false });
    div.addEventListener('touchend', onTouchEnd, { passive: false });

    return div;
  }

  // ===== äº¤æ› DOMï¼ˆä¸é‡å»ºæ•´å€‹æ£‹ç›¤ï¼‰=====
  function swapPiecesDOM(i, j) {
    const allDivs = puzzleBoard.querySelectorAll('.puzzle-piece');
    const divI = allDivs[i];
    const divJ = allDivs[j];

    // ç”¨æ–°çš„ div æ›¿æ›ï¼Œä¿ç•™ä½ç½®
    const newDivI = createPieceDiv(pieces[i], i);
    const newDivJ = createPieceDiv(pieces[j], j);

    // åŠ ä¸Šäº¤æ›å‹•ç•«
    newDivI.classList.add('swap-anim');
    newDivJ.classList.add('swap-anim');

    divI.replaceWith(newDivI);
    divJ.replaceWith(newDivJ);
  }

  // ===== æ‹–æ‹‰ (æ¡Œé¢) =====
  let dragFromIndex = null;

  function onDragStart(e) {
    dragFromIndex = parseInt(this.dataset.index);
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', dragFromIndex);
  }

  function onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  }

  function onDragEnter(e) {
    e.preventDefault();
    this.classList.add('drag-over');
  }

  function onDragLeave() {
    this.classList.remove('drag-over');
  }

  function onDrop(e) {
    e.preventDefault();
    this.classList.remove('drag-over');
    const toIndex = parseInt(this.dataset.index);
    if (dragFromIndex !== null && dragFromIndex !== toIndex) {
      swapPieces(dragFromIndex, toIndex);
    }
  }

  function onDragEnd() {
    this.classList.remove('dragging');
    dragFromIndex = null;
  }

  // ===== è§¸æ§æ‹–æ‹‰ (æ‰‹æ©Ÿ) =====
  let touchPiece = null;
  let touchClone = null;
  let touchFromIndex = null;
  let touchStartX = 0;
  let touchStartY = 0;
  let isTouchDragging = false;

  function onTouchStart(e) {
    if (!gameActive) return;
    e.preventDefault();

    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchPiece = this;
    touchFromIndex = parseInt(this.dataset.index);
    isTouchDragging = false;
  }

  function onTouchMove(e) {
    if (!touchPiece) return;
    e.preventDefault();

    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    // è¶…éé–¾å€¼æ‰é€²å…¥æ‹–æ‹‰æ¨¡å¼
    if (!isTouchDragging && (Math.abs(dx) > 10 || Math.abs(dy) > 10)) {
      isTouchDragging = true;
      selectedIndex = null;
      clearSelection();

      // å»ºç«‹æ‹–æ‹‰ç”¨çš„ clone
      touchClone = touchPiece.cloneNode(true);
      touchClone.style.position = 'fixed';
      touchClone.style.zIndex = '999';
      touchClone.style.pointerEvents = 'none';
      touchClone.style.opacity = '0.85';
      touchClone.style.transform = 'scale(1.1)';
      touchClone.style.boxShadow = '0 8px 30px rgba(255,210,0,0.4)';
      touchClone.style.width = touchPiece.offsetWidth + 'px';
      touchClone.style.height = touchPiece.offsetHeight + 'px';
      document.body.appendChild(touchClone);

      touchPiece.classList.add('dragging');
    }

    if (isTouchDragging && touchClone) {
      touchClone.style.left = (touch.clientX - touchPiece.offsetWidth / 2) + 'px';
      touchClone.style.top = (touch.clientY - touchPiece.offsetHeight / 2) + 'px';

      // é«˜äº®ç›®æ¨™
      const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
      allPieces.forEach(p => p.classList.remove('drag-over'));

      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target) {
        const targetPiece = target.closest('.puzzle-piece');
        if (targetPiece && targetPiece !== touchPiece) {
          targetPiece.classList.add('drag-over');
        }
      }
    }
  }

  function onTouchEnd(e) {
    if (!touchPiece) return;
    e.preventDefault();

    if (isTouchDragging) {
      // æ‹–æ‹‰å®Œæˆ - æ‰¾åˆ°ç›®æ¨™
      if (touchClone) {
        document.body.removeChild(touchClone);
        touchClone = null;
      }

      touchPiece.classList.remove('dragging');

      const touch = e.changedTouches[0];
      const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
      allPieces.forEach(p => p.classList.remove('drag-over'));

      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target) {
        const targetPiece = target.closest('.puzzle-piece');
        if (targetPiece && targetPiece !== touchPiece) {
          const toIndex = parseInt(targetPiece.dataset.index);
          swapPieces(touchFromIndex, toIndex);
        }
      }
    } else {
      // çŸ­æŒ‰ = é»æ“Šé¸å–
      onPieceClick(touchFromIndex);
    }

    touchPiece = null;
    touchFromIndex = null;
    isTouchDragging = false;
  }

  // ===== é»æ“Šäº¤æ› =====
  function onPieceClick(index) {
    if (!gameActive) return;

    const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');

    if (selectedIndex === null) {
      selectedIndex = index;
      allPieces[index].classList.add('selected');
    } else if (selectedIndex === index) {
      // å–æ¶ˆé¸å–
      allPieces[index].classList.remove('selected');
      selectedIndex = null;
    } else {
      // äº¤æ›
      swapPieces(selectedIndex, index);
      selectedIndex = null;
    }
  }

  function clearSelection() {
    const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
    allPieces.forEach(p => p.classList.remove('selected'));
  }

  // ===== äº¤æ›é‚è¼¯ =====
  function swapPieces(i, j) {
    if (!gameActive) return;

    // å•Ÿå‹•è¨ˆæ™‚å™¨
    if (!timerStarted) {
      timerStarted = true;
      startTimer();
    }

    moveCount++;

    [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
    swapPiecesDOM(i, j);

    // æª¢æŸ¥æ˜¯å¦å®Œæˆ
    if (checkComplete()) {
      onComplete();
    }
  }

  function checkComplete() {
    return pieces.every((piece, index) => piece.correctIndex === index);
  }

  // ===== è¨ˆæ™‚å™¨ =====
  function startTimer() {
    timerInterval = setInterval(() => {
      seconds++;
      timerEl.textContent = formatTime(seconds);
    }, 1000);
  }

  function resetTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    seconds = 0;
    timerStarted = false;
    timerEl.textContent = '00:00';
  }

  function formatTime(s) {
    const min = Math.floor(s / 60);
    const sec = s % 60;
    return String(min).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
  }

  // ===== å®Œæˆ =====
  function onComplete() {
    gameActive = false;
    clearInterval(timerInterval);

    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;

    let timeStr = '';
    if (min > 0) timeStr += min + ' åˆ† ';
    timeStr += sec + ' ç§’';

    completeStats.innerHTML =
      'é›£åº¦ï¼š' + gridSize + 'Ã—' + gridSize + '<br>' +
      'ç”¨æ™‚ï¼š' + timeStr + '<br>' +
      'æ­¥æ•¸ï¼š' + moveCount + ' æ­¥';

    completeImage.src = imageDataURL;

    setTimeout(() => {
      completeOverlay.classList.add('show');
    }, 400);
  }

  // ===== åŸåœ–é è¦½ =====
  btnPreview.addEventListener('click', function() {
    previewFull.src = imageDataURL;
    previewOverlay.classList.add('show');
  });

  previewOverlay.addEventListener('click', function() {
    previewOverlay.classList.remove('show');
  });

  // ===== å›é¦–é  =====
  btnRestart.addEventListener('click', function() {
    resetTimer();
    gameActive = false;
    timerStarted = false;
    moveCount = 0;
    selectedIndex = null;

    // å›åˆ°ä¸Šå‚³ç•«é¢
    screenGame.style.display = 'none';
    screenUpload.style.display = 'flex';
  });

  // ===== å®Œæˆå¾ŒæŒ‰éˆ• =====
  btnPlayAgain.addEventListener('click', function() {
    completeOverlay.classList.remove('show');
    resetTimer();
    gameActive = true;
    timerStarted = false;
    moveCount = 0;
    selectedIndex = null;
    buildPuzzle();
  });

  btnNewImage.addEventListener('click', function() {
    completeOverlay.classList.remove('show');
    screenGame.style.display = 'none';
    screenUpload.style.display = 'flex';

    // é‡ç½®ä¸Šå‚³å€
    uploadedImage = null;
    imageDataURL = null;
    uploadZone.classList.remove('has-image');
    const existing = uploadZone.querySelector('.preview-img');
    if (existing) existing.remove();
    uploadIcon.style.display = '';
    uploadText.style.display = '';
    btnStart.classList.remove('ready');
    fileInput.value = '';

    resetTimer();
  });

})();
</script>
</body>
</html>
