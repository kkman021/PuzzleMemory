<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- SEO Meta Tags -->
<title>æ‹¼åœ–è¨˜æ†¶éŠæˆ² - ä¸Šå‚³ç…§ç‰‡æŒ‘æˆ°æ‹¼åœ–</title>
<meta name="description" content="ä¸Šå‚³ä½ å–œæ„›çš„ç…§ç‰‡ï¼ŒæŒ‘æˆ°æ‹¼åœ–è¨˜æ†¶éŠæˆ²ï¼æ”¯æ´ 3x3ã€4x4ã€5x5 é›£åº¦ï¼Œè¨“ç·´è§€å¯ŸåŠ›èˆ‡è¨˜æ†¶åŠ›ï¼Œé©åˆæ‰€æœ‰å¹´é½¡å±¤çš„ç›Šæ™ºéŠæˆ²ã€‚">
<meta name="keywords" content="æ‹¼åœ–éŠæˆ², è¨˜æ†¶éŠæˆ², ç›Šæ™ºéŠæˆ², puzzle game, ç…§ç‰‡æ‹¼åœ–, ç·šä¸Šæ‹¼åœ–, æ‰‹æ©ŸéŠæˆ²">
<meta name="author" content="PuzzleMemory">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://puzzle-memory.pages.dev/">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="æ‹¼åœ–è¨˜æ†¶éŠæˆ² - ä¸Šå‚³ç…§ç‰‡æŒ‘æˆ°æ‹¼åœ–">
<meta property="og:description" content="ä¸Šå‚³ä½ å–œæ„›çš„ç…§ç‰‡ï¼ŒæŒ‘æˆ°æ‹¼åœ–è¨˜æ†¶éŠæˆ²ï¼æ”¯æ´å¤šç¨®é›£åº¦ï¼Œè¨“ç·´è§€å¯ŸåŠ›èˆ‡è¨˜æ†¶åŠ›ã€‚">
<meta property="og:url" content="https://puzzle-memory.pages.dev/">
<meta property="og:locale" content="zh_TW">
<meta property="og:site_name" content="æ‹¼åœ–è¨˜æ†¶éŠæˆ²">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="æ‹¼åœ–è¨˜æ†¶éŠæˆ² - ä¸Šå‚³ç…§ç‰‡æŒ‘æˆ°æ‹¼åœ–">
<meta name="twitter:description" content="ä¸Šå‚³ä½ å–œæ„›çš„ç…§ç‰‡ï¼ŒæŒ‘æˆ°æ‹¼åœ–è¨˜æ†¶éŠæˆ²ï¼æ”¯æ´å¤šç¨®é›£åº¦ï¼Œè¨“ç·´è§€å¯ŸåŠ›èˆ‡è¨˜æ†¶åŠ›ã€‚">

<!-- Favicon -->
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="theme-color" content="#302b63">
<style>
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
  top: 0;
  left: 0;
  touch-action: none;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: none;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* ===== æ˜Ÿç©ºèƒŒæ™¯ ===== */
.starfield {
  position: fixed;
  inset: 0;
  z-index: 0;
  pointer-events: none;
  overflow: hidden;
}

.star {
  position: absolute;
  border-radius: 50%;
  background: #fff;
  animation: twinkle var(--duration) ease-in-out infinite alternate;
  opacity: 0;
}

@keyframes twinkle {
  0% { opacity: 0.1; transform: scale(0.8); }
  100% { opacity: var(--max-opacity, 0.9); transform: scale(1.2); }
}

#screen-upload, #screen-game {
  position: relative;
  z-index: 1;
}

.complete-overlay {
  z-index: 100;
}

/* ===== ä¸Šå‚³ç•«é¢ ===== */
#screen-upload {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  padding: 20px;
  gap: 24px;
}

.game-title {
  font-size: 28px;
  font-weight: 800;
  letter-spacing: 2px;
  background: linear-gradient(90deg, #f7971e, #ffd200);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.upload-zone {
  width: 90%;
  max-width: 320px;
  aspect-ratio: 1;
  border: 3px dashed rgba(255,255,255,0.3);
  border-radius: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.upload-zone.has-image {
  border-color: #ffd200;
}

.upload-zone:active {
  transform: scale(0.97);
}

.upload-zone .icon {
  font-size: 48px;
  opacity: 0.6;
}

.upload-zone .text {
  font-size: 16px;
  opacity: 0.6;
}

.upload-zone .preview-img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 17px;
}

#file-input {
  display: none;
}

.difficulty-section {
  text-align: center;
}

.difficulty-section label {
  font-size: 14px;
  opacity: 0.7;
  display: block;
  margin-bottom: 10px;
}

.difficulty-btns {
  display: flex;
  gap: 12px;
}

.diff-btn {
  padding: 10px 22px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  background: transparent;
  color: #fff;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.diff-btn.active {
  border-color: #ffd200;
  background: rgba(255, 210, 0, 0.15);
  color: #ffd200;
}

.diff-btn:active {
  transform: scale(0.95);
}

.btn-start {
  padding: 14px 48px;
  border: none;
  border-radius: 14px;
  background: linear-gradient(135deg, #f7971e, #ffd200);
  color: #1a1a2e;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  opacity: 0.4;
  pointer-events: none;
}

.btn-start.ready {
  opacity: 1;
  pointer-events: auto;
}

.btn-start:active {
  transform: scale(0.95);
}

/* ===== éŠæˆ²ç•«é¢ ===== */
#screen-game {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
  height: 100%;
  padding: 12px;
  gap: 10px;
}

.top-bar {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 0;
}

.timer {
  font-size: 22px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: #ffd200;
}

.top-actions {
  display: flex;
  gap: 8px;
}

.btn-sm {
  padding: 8px 14px;
  border: 1.5px solid rgba(255,255,255,0.3);
  border-radius: 10px;
  background: rgba(255,255,255,0.08);
  color: #fff;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-sm:active {
  transform: scale(0.93);
  background: rgba(255,255,255,0.15);
}

.puzzle-container {
  flex: 1;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.puzzle-board {
  display: grid;
  gap: 2px;
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  padding: 4px;
  position: relative;
}

.puzzle-piece {
  border-radius: 6px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
  position: relative;
}

.puzzle-piece canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.puzzle-piece.selected {
  transform: scale(1.05);
  box-shadow: 0 0 0 3px #ffd200, 0 4px 20px rgba(255,210,0,0.4);
  z-index: 10;
}

.puzzle-piece.correct {
  opacity: 1;
}

.puzzle-piece.correct::after {
  content: '';
  position: absolute;
  inset: 0;
  border: 2px solid rgba(76, 217, 100, 0.6);
  border-radius: 6px;
  pointer-events: none;
}

.puzzle-piece.dragging {
  opacity: 0.5;
  transform: scale(0.9);
}

.puzzle-piece.drag-over {
  box-shadow: 0 0 0 3px #00bcd4, 0 4px 15px rgba(0,188,212,0.3);
}

.hint-text {
  font-size: 12px;
  opacity: 0.4;
  text-align: center;
  padding: 4px;
}

/* ===== åŸåœ–é è¦½ï¼ˆæ£‹ç›¤å…§ç–ŠåŠ ï¼‰ ===== */
.puzzle-board-wrapper {
  position: relative;
  display: inline-block;
}

.inline-preview {
  position: absolute;
  inset: 0;
  z-index: 50;
  border-radius: 12px;
  overflow: hidden;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.inline-preview.show {
  opacity: 1;
  pointer-events: auto;
}

.inline-preview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 12px;
}

.inline-preview .preview-label {
  position: absolute;
  bottom: 8px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.6);
  color: #ffd200;
  padding: 4px 14px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
  white-space: nowrap;
}

/* ===== å®Œæˆç•«é¢ ===== */
.complete-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 200;
  background: rgba(15, 12, 41, 0.95);
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 20px;
  padding: 20px;
}

.complete-overlay.show {
  display: flex;
}

.complete-title {
  font-size: 36px;
  font-weight: 800;
  background: linear-gradient(90deg, #f7971e, #ffd200);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.complete-stats {
  text-align: center;
  font-size: 18px;
  line-height: 2;
  opacity: 0.8;
}

.complete-actions {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn-complete {
  padding: 12px 28px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  background: transparent;
  color: #fff;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-complete:active {
  transform: scale(0.95);
}

.btn-complete.primary {
  border-color: #ffd200;
  background: rgba(255, 210, 0, 0.15);
  color: #ffd200;
}

.complete-image {
  max-width: 60%;
  max-height: 30vh;
  border-radius: 12px;
  object-fit: contain;
}

/* ===== æˆåŠŸæ…¶ç¥ç‰¹æ•ˆ ===== */
.confetti-container {
  position: fixed;
  inset: 0;
  z-index: 90;
  pointer-events: none;
  overflow: hidden;
}

.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  top: -10px;
  animation: confetti-fall var(--fall-duration, 3s) linear forwards;
}

@keyframes confetti-fall {
  0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
  80% { opacity: 1; }
  100% { transform: translateY(100vh) rotate(var(--spin, 720deg)) scale(0.3); opacity: 0; }
}

.puzzle-board.celebrate .puzzle-piece {
  animation: celebrate-pulse 0.6s ease-in-out;
}

@keyframes celebrate-pulse {
  0% { transform: scale(1); }
  30% { transform: scale(1.06); box-shadow: 0 0 20px rgba(255,210,0,0.5); }
  100% { transform: scale(1); }
}

/* ===== å‹•ç•« ===== */
@keyframes pop-in {
  0% { transform: scale(0.5); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes swap-pop {
  0% { transform: scale(0.85); }
  50% { transform: scale(1.08); }
  100% { transform: scale(1); }
}

.puzzle-piece.pop-in-anim {
  animation: pop-in 0.3s ease-out both;
}

.puzzle-piece.swap-pop-anim {
  animation: swap-pop 0.3s ease-out both;
}
</style>
</head>
<body>

<!-- ===== æ˜Ÿç©ºèƒŒæ™¯ ===== -->
<div class="starfield" id="starfield"></div>

<!-- ===== ä¸Šå‚³ç•«é¢ ===== -->
<div id="screen-upload">
  <div class="game-title">æ‹¼åœ–è¨˜æ†¶éŠæˆ²</div>

  <div class="upload-zone" id="upload-zone">
    <div class="icon" id="upload-icon">ğŸ“</div>
    <div class="text" id="upload-text">é»æ“Šé¸æ“‡åœ–ç‰‡</div>
  </div>
  <input type="file" id="file-input" accept="image/jpeg,image/jpg,image/png,image/gif,image/webp,image/heic,image/heif,image/bmp">

  <div class="difficulty-section">
    <label>é¸æ“‡é›£åº¦</label>
    <div class="difficulty-btns">
      <button class="diff-btn active" data-grid="3">3Ã—3</button>
      <button class="diff-btn" data-grid="4">4Ã—4</button>
      <button class="diff-btn" data-grid="5">5Ã—5</button>
    </div>
  </div>

  <button class="btn-start" id="btn-start">é–‹å§‹éŠæˆ²</button>
</div>

<!-- ===== éŠæˆ²ç•«é¢ ===== -->
<div id="screen-game">
  <div class="top-bar">
    <div class="timer" id="timer">00:00</div>
    <div class="top-actions">
      <button class="btn-sm" id="btn-preview">é¡¯ç¤ºåŸåœ–</button>
      <button class="btn-sm" id="btn-restart">å›é¦–é </button>
    </div>
  </div>

  <div class="puzzle-container">
    <div class="puzzle-board-wrapper">
      <div class="puzzle-board" id="puzzle-board"></div>
      <div class="inline-preview" id="inline-preview">
        <img id="preview-full" src="" alt="åŸåœ–">
        <div class="preview-label">é¬†é–‹éš±è—åŸåœ–</div>
      </div>
    </div>
  </div>

  <div class="hint-text">æ‹–æ‹‰äº¤æ› æˆ– é»æ“Šå…©å¡Šäº¤æ›ä½ç½® | é•·æŒ‰ã€Œé¡¯ç¤ºåŸåœ–ã€æŸ¥çœ‹</div>
</div>

<!-- ===== å®Œæˆç•«é¢ ===== -->
<div class="complete-overlay" id="complete-overlay">
  <div class="complete-title">æ­å–œå®Œæˆï¼</div>
  <img class="complete-image" id="complete-image" src="" alt="å®Œæˆåœ–">
  <div class="complete-stats" id="complete-stats"></div>
  <div class="complete-actions">
    <button class="btn-complete primary" id="btn-play-again">å†ç©ä¸€æ¬¡</button>
    <button class="btn-complete" id="btn-new-image">æ›å¼µåœ–ç‰‡</button>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ===== é˜²æ­¢æ‰€æœ‰å¹²æ“¾æ‰‹å‹¢ =====
  document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend', e => e.preventDefault(), { passive: false });

  document.addEventListener('touchmove', function(e) {
    if (e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  let lastTouchEnd = 0;
  document.addEventListener('touchend', function(e) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  document.addEventListener('contextmenu', e => e.preventDefault());

  document.body.addEventListener('touchmove', function(e) {
    if (!e.target.closest('.puzzle-board')) e.preventDefault();
  }, { passive: false });

  // ===== æ˜Ÿç©ºèƒŒæ™¯ =====
  function createStarfield() {
    const container = document.getElementById('starfield');
    const count = 120;
    for (let i = 0; i < count; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      const size = Math.random() * 3 + 1;
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 100 + '%';
      star.style.setProperty('--duration', (Math.random() * 3 + 1.5) + 's');
      star.style.setProperty('--max-opacity', (Math.random() * 0.6 + 0.3).toFixed(2));
      star.style.animationDelay = (Math.random() * 4) + 's';
      container.appendChild(star);
    }
  }
  createStarfield();

  // ===== éŸ³æ•ˆç³»çµ±ï¼ˆWeb Audio APIï¼‰ =====
  let audioCtx = null;

  function getAudioContext() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  }

  function playSuccessSound() {
    try {
      const ctx = getAudioContext();
      const now = ctx.currentTime;

      // æˆåŠŸæ—‹å¾‹ï¼šC5 - E5 - G5 - C6ï¼ˆä¸Šè¡Œå¤§ä¸‰å’Œå¼¦ï¼‰
      const notes = [523.25, 659.25, 783.99, 1046.50];
      const durations = [0.15, 0.15, 0.15, 0.4];

      let offset = 0;
      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.type = 'sine';
        osc.frequency.value = freq;

        gain.gain.setValueAtTime(0, now + offset);
        gain.gain.linearRampToValueAtTime(0.15, now + offset + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + offset + durations[i]);

        osc.start(now + offset);
        osc.stop(now + offset + durations[i] + 0.05);
        offset += durations[i];
      });

      // åŠ ä¸€å€‹æŸ”å’Œçš„å’Œå¼¦å¢Šåº•
      const pad = ctx.createOscillator();
      const padGain = ctx.createGain();
      pad.connect(padGain);
      padGain.connect(ctx.destination);
      pad.type = 'triangle';
      pad.frequency.value = 261.63; // C4
      padGain.gain.setValueAtTime(0, now);
      padGain.gain.linearRampToValueAtTime(0.08, now + 0.1);
      padGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
      pad.start(now);
      pad.stop(now + 1.3);
    } catch (e) {
      // éœé»˜å¤±æ•—ï¼Œä¸å½±éŸ¿éŠæˆ²
    }
  }

  // ===== æ…¶ç¥ç‰¹æ•ˆï¼šå½©è‰²ç´™ç‰‡ =====
  function launchConfetti() {
    const container = document.createElement('div');
    container.className = 'confetti-container';
    document.body.appendChild(container);

    const colors = ['#ffd200', '#f7971e', '#ff6b6b', '#48dbfb', '#0abde3', '#ff9ff3', '#54a0ff', '#5f27cd'];
    const shapes = ['circle', 'square', 'triangle'];

    for (let i = 0; i < 60; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      const color = colors[Math.floor(Math.random() * colors.length)];
      const shape = shapes[Math.floor(Math.random() * shapes.length)];
      const size = Math.random() * 8 + 6;

      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.width = size + 'px';
      confetti.style.height = size + 'px';
      confetti.style.setProperty('--fall-duration', (Math.random() * 2 + 2) + 's');
      confetti.style.setProperty('--spin', (Math.random() * 1080 - 360) + 'deg');
      confetti.style.animationDelay = (Math.random() * 0.8) + 's';

      if (shape === 'circle') {
        confetti.style.borderRadius = '50%';
        confetti.style.background = color;
      } else if (shape === 'square') {
        confetti.style.background = color;
        confetti.style.borderRadius = '2px';
      } else {
        confetti.style.width = '0';
        confetti.style.height = '0';
        confetti.style.borderLeft = size / 2 + 'px solid transparent';
        confetti.style.borderRight = size / 2 + 'px solid transparent';
        confetti.style.borderBottom = size + 'px solid ' + color;
        confetti.style.background = 'transparent';
      }

      container.appendChild(confetti);
    }

    setTimeout(() => {
      container.remove();
    }, 4000);
  }

  // ===== ç‹€æ…‹ =====
  let uploadedImage = null;
  let imageDataURL = null;
  let gridSize = 3;
  let pieces = [];
  let selectedIndex = null;
  let timerInterval = null;
  let seconds = 0;
  let timerStarted = false;
  let gameActive = false;
  let moveCount = 0;

  // ===== DOM =====
  const screenUpload = document.getElementById('screen-upload');
  const screenGame = document.getElementById('screen-game');
  const uploadZone = document.getElementById('upload-zone');
  const fileInput = document.getElementById('file-input');
  const uploadIcon = document.getElementById('upload-icon');
  const uploadText = document.getElementById('upload-text');
  const btnStart = document.getElementById('btn-start');
  const diffBtns = document.querySelectorAll('.diff-btn');
  const puzzleBoard = document.getElementById('puzzle-board');
  const timerEl = document.getElementById('timer');
  const btnPreview = document.getElementById('btn-preview');
  const btnRestart = document.getElementById('btn-restart');
  const inlinePreview = document.getElementById('inline-preview');
  const previewFull = document.getElementById('preview-full');
  const completeOverlay = document.getElementById('complete-overlay');
  const completeImage = document.getElementById('complete-image');
  const completeStats = document.getElementById('complete-stats');
  const btnPlayAgain = document.getElementById('btn-play-again');
  const btnNewImage = document.getElementById('btn-new-image');

  // ===== ä¸Šå‚³å€ =====
  uploadZone.addEventListener('click', () => {
    // é‡ç½® inputï¼Œç¢ºä¿æ¯æ¬¡æ‰“é–‹éƒ½æ˜¯ä¹¾æ·¨ç‹€æ…‹
    // é€™æœ‰åŠ©æ–¼æ”¹å–„æŸäº›è£ç½®ä¸Šç›¸ç°¿è¼‰å…¥ä¸å®Œæ•´çš„å•é¡Œ
    fileInput.value = '';
    // æ·»åŠ å¾®å°å»¶é²è®“ç³»çµ±æœ‰æ™‚é–“æº–å‚™
    setTimeout(() => {
      fileInput.click();
    }, 50);
  });

  fileInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) handleImageFile(file);
  });

  function handleImageFile(file) {
    if (!file.type.startsWith('image/')) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      imageDataURL = e.target.result;
      const img = new Image();
      img.onload = function() {
        uploadedImage = img;

        uploadZone.classList.add('has-image');
        const existing = uploadZone.querySelector('.preview-img');
        if (existing) existing.remove();
        const preview = document.createElement('img');
        preview.className = 'preview-img';
        preview.src = imageDataURL;
        uploadZone.appendChild(preview);
        uploadIcon.style.display = 'none';
        uploadText.style.display = 'none';

        btnStart.classList.add('ready');
      };
      img.src = imageDataURL;
    };
    reader.readAsDataURL(file);
  }

  // ===== é›£åº¦é¸æ“‡ =====
  diffBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      diffBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      gridSize = parseInt(this.dataset.grid);
    });
  });

  // ===== é–‹å§‹éŠæˆ² =====
  btnStart.addEventListener('click', startGame);

  async function startGame() {
    if (!uploadedImage) return;

    screenUpload.style.display = 'none';
    screenGame.style.display = 'flex';

    resetTimer();
    gameActive = true;
    moveCount = 0;
    selectedIndex = null;

    // è¨­å®š inline preview åœ–ç‰‡
    previewFull.src = imageDataURL;

    await buildPuzzle();
  }

  // ===== å»ºç«‹æ‹¼åœ– =====
  async function buildPuzzle() {
    puzzleBoard.innerHTML = '';

    const containerEl = document.querySelector('.puzzle-container');
    const maxW = containerEl.clientWidth - 8;
    const maxH = containerEl.clientHeight - 8;
    const boardSize = Math.min(maxW, maxH);
    const pieceSize = Math.floor((boardSize - (gridSize - 1) * 2 - 8) / gridSize);
    const totalSize = pieceSize * gridSize + (gridSize - 1) * 2 + 8;

    puzzleBoard.style.gridTemplateColumns = `repeat(${gridSize}, ${pieceSize}px)`;
    puzzleBoard.style.gridTemplateRows = `repeat(${gridSize}, ${pieceSize}px)`;
    puzzleBoard.style.width = totalSize + 'px';
    puzzleBoard.style.height = totalSize + 'px';

    const img = uploadedImage;

    // ç¢ºä¿åœ–ç‰‡å®Œå…¨è¼‰å…¥å’Œè§£ç¢¼ï¼Œé¿å…éƒ¨åˆ†è¼‰å…¥å•é¡Œ
    if (img.decode) {
      try {
        await img.decode();
      } catch (e) {
        // å¦‚æœ decode å¤±æ•—ï¼Œç¹¼çºŒåŸ·è¡Œï¼ˆå…¼å®¹èˆŠç€è¦½å™¨ï¼‰
      }
    }

    // å¦‚æœåœ–ç‰‡é‚„æ²’å®Œå…¨è¼‰å…¥ï¼Œç­‰å¾…è¼‰å…¥å®Œæˆ
    if (!img.complete) {
      await new Promise((resolve) => {
        img.onload = resolve;
        img.onerror = resolve; // å³ä½¿éŒ¯èª¤ä¹Ÿç¹¼çºŒ
      });
    }

    const cropSize = Math.min(img.width, img.height);
    const sx = (img.width - cropSize) / 2;
    const sy = (img.height - cropSize) / 2;
    const srcPieceSize = cropSize / gridSize;

    pieces = [];
    const total = gridSize * gridSize;

    for (let i = 0; i < total; i++) {
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;

      const canvas = document.createElement('canvas');
      canvas.width = pieceSize * 2;
      canvas.height = pieceSize * 2;
      canvas.style.width = pieceSize + 'px';
      canvas.style.height = pieceSize + 'px';

      const ctx = canvas.getContext('2d');
      ctx.drawImage(
        img,
        sx + col * srcPieceSize, sy + row * srcPieceSize,
        srcPieceSize, srcPieceSize,
        0, 0,
        pieceSize * 2, pieceSize * 2
      );

      pieces.push({ correctIndex: i, canvas: canvas });
    }

    let shuffled;
    do {
      shuffled = [...pieces];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
    } while (shuffled.some((p, i) => p.correctIndex === i));

    pieces = shuffled;
    renderBoard();
  }

  // ===== æ¸²æŸ“æ‹¼åœ– =====
  function renderBoard() {
    puzzleBoard.innerHTML = '';

    pieces.forEach((piece, index) => {
      const div = createPieceElement(piece, index);
      div.classList.add('pop-in-anim');
      div.style.animationDelay = (index * 0.03) + 's';
      puzzleBoard.appendChild(div);
    });
  }

  function createPieceElement(piece, index) {
    const div = document.createElement('div');
    div.className = 'puzzle-piece';
    div.dataset.index = index;
    div.appendChild(piece.canvas);

    if (piece.correctIndex === index) {
      div.classList.add('correct');
    }

    div.draggable = true;
    div.addEventListener('dragstart', onDragStart);
    div.addEventListener('dragover', onDragOver);
    div.addEventListener('dragenter', onDragEnter);
    div.addEventListener('dragleave', onDragLeave);
    div.addEventListener('drop', onDrop);
    div.addEventListener('dragend', onDragEnd);

    div.addEventListener('click', () => onPieceClick(index));

    div.addEventListener('touchstart', onTouchStart, { passive: false });
    div.addEventListener('touchmove', onTouchMove, { passive: false });
    div.addEventListener('touchend', onTouchEnd, { passive: false });

    return div;
  }

  // ===== DOM äº¤æ› =====
  function swapPiecesDOM(i, j) {
    const allDivs = puzzleBoard.querySelectorAll('.puzzle-piece');
    const divI = allDivs[i];
    const divJ = allDivs[j];

    const newDivI = createPieceElement(pieces[i], i);
    const newDivJ = createPieceElement(pieces[j], j);

    newDivI.classList.add('swap-pop-anim');
    newDivJ.classList.add('swap-pop-anim');

    puzzleBoard.replaceChild(newDivJ, divJ);
    puzzleBoard.replaceChild(newDivI, divI);
  }

  // ===== æ‹–æ‹‰ (æ¡Œé¢) =====
  let dragFromIndex = null;

  function onDragStart(e) {
    dragFromIndex = parseInt(this.dataset.index);
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', dragFromIndex);
  }

  function onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  }

  function onDragEnter(e) {
    e.preventDefault();
    this.classList.add('drag-over');
  }

  function onDragLeave() {
    this.classList.remove('drag-over');
  }

  function onDrop(e) {
    e.preventDefault();
    this.classList.remove('drag-over');
    const toIndex = parseInt(this.dataset.index);
    if (dragFromIndex !== null && dragFromIndex !== toIndex) {
      swapPieces(dragFromIndex, toIndex);
    }
  }

  function onDragEnd() {
    this.classList.remove('dragging');
    dragFromIndex = null;
  }

  // ===== è§¸æ§æ‹–æ‹‰ (æ‰‹æ©Ÿ) =====
  let touchPiece = null;
  let touchClone = null;
  let touchFromIndex = null;
  let touchStartX = 0;
  let touchStartY = 0;
  let isTouchDragging = false;

  function onTouchStart(e) {
    if (!gameActive) return;
    e.preventDefault();

    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchPiece = this;
    touchFromIndex = parseInt(this.dataset.index);
    isTouchDragging = false;
  }

  function onTouchMove(e) {
    if (!touchPiece) return;
    e.preventDefault();

    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    if (!isTouchDragging && (Math.abs(dx) > 10 || Math.abs(dy) > 10)) {
      isTouchDragging = true;
      selectedIndex = null;
      clearSelection();

      touchClone = touchPiece.cloneNode(true);
      touchClone.style.position = 'fixed';
      touchClone.style.zIndex = '999';
      touchClone.style.pointerEvents = 'none';
      touchClone.style.opacity = '0.85';
      touchClone.style.transform = 'scale(1.1)';
      touchClone.style.boxShadow = '0 8px 30px rgba(255,210,0,0.4)';
      touchClone.style.width = touchPiece.offsetWidth + 'px';
      touchClone.style.height = touchPiece.offsetHeight + 'px';
      document.body.appendChild(touchClone);

      touchPiece.classList.add('dragging');
    }

    if (isTouchDragging && touchClone) {
      touchClone.style.left = (touch.clientX - touchPiece.offsetWidth / 2) + 'px';
      touchClone.style.top = (touch.clientY - touchPiece.offsetHeight / 2) + 'px';

      const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
      allPieces.forEach(p => p.classList.remove('drag-over'));

      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target) {
        const targetPiece = target.closest('.puzzle-piece');
        if (targetPiece && targetPiece !== touchPiece) {
          targetPiece.classList.add('drag-over');
        }
      }
    }
  }

  function onTouchEnd(e) {
    if (!touchPiece) return;
    e.preventDefault();

    if (isTouchDragging) {
      if (touchClone) {
        document.body.removeChild(touchClone);
        touchClone = null;
      }

      touchPiece.classList.remove('dragging');

      const touch = e.changedTouches[0];
      const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
      allPieces.forEach(p => p.classList.remove('drag-over'));

      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target) {
        const targetPiece = target.closest('.puzzle-piece');
        if (targetPiece && targetPiece !== touchPiece) {
          const toIndex = parseInt(targetPiece.dataset.index);
          swapPieces(touchFromIndex, toIndex);
        }
      }
    } else {
      onPieceClick(touchFromIndex);
    }

    touchPiece = null;
    touchFromIndex = null;
    isTouchDragging = false;
  }

  // ===== é»æ“Šäº¤æ› =====
  function onPieceClick(index) {
    if (!gameActive) return;

    const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');

    if (selectedIndex === null) {
      selectedIndex = index;
      allPieces[index].classList.add('selected');
    } else if (selectedIndex === index) {
      allPieces[index].classList.remove('selected');
      selectedIndex = null;
    } else {
      swapPieces(selectedIndex, index);
      selectedIndex = null;
    }
  }

  function clearSelection() {
    const allPieces = puzzleBoard.querySelectorAll('.puzzle-piece');
    allPieces.forEach(p => p.classList.remove('selected'));
  }

  // ===== äº¤æ›é‚è¼¯ =====
  function swapPieces(i, j) {
    if (!gameActive) return;

    if (!timerStarted) {
      timerStarted = true;
      startTimer();
    }

    moveCount++;

    // æ¸…é™¤é¸æ“‡ç‹€æ…‹ï¼Œé¿å…é»ƒæ¡†æ®˜ç•™
    clearSelection();

    [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
    swapPiecesDOM(i, j);

    if (checkComplete()) {
      onComplete();
    }
  }

  function checkComplete() {
    return pieces.every((piece, index) => piece.correctIndex === index);
  }

  // ===== è¨ˆæ™‚å™¨ =====
  function startTimer() {
    timerInterval = setInterval(() => {
      seconds++;
      timerEl.textContent = formatTime(seconds);
    }, 1000);
  }

  function resetTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    seconds = 0;
    timerStarted = false;
    timerEl.textContent = '00:00';
  }

  function formatTime(s) {
    const min = Math.floor(s / 60);
    const sec = s % 60;
    return String(min).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
  }

  // ===== å®Œæˆ =====
  function onComplete() {
    gameActive = false;
    clearInterval(timerInterval);

    // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
    playSuccessSound();

    // ç™¼å°„å½©è‰²ç´™ç‰‡
    launchConfetti();

    // æ‹¼åœ–æ¿æ…¶ç¥å‹•ç•«
    puzzleBoard.classList.add('celebrate');
    setTimeout(() => puzzleBoard.classList.remove('celebrate'), 800);

    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;

    let timeStr = '';
    if (min > 0) timeStr += min + ' åˆ† ';
    timeStr += sec + ' ç§’';

    completeStats.innerHTML =
      'é›£åº¦ï¼š' + gridSize + 'Ã—' + gridSize + '<br>' +
      'ç”¨æ™‚ï¼š' + timeStr + '<br>' +
      'æ­¥æ•¸ï¼š' + moveCount + ' æ­¥';

    completeImage.src = imageDataURL;

    setTimeout(() => {
      completeOverlay.classList.add('show');
    }, 600);
  }

  // ===== åŸåœ–é è¦½ï¼ˆé•·æŒ‰/æŒ‰ä½é¡¯ç¤ºï¼Œé¬†é–‹éš±è—ï¼‰ =====
  let previewActive = false;

  // æ»‘é¼ ï¼šæŒ‰ä¸‹é¡¯ç¤ºï¼Œé¬†é–‹éš±è—
  btnPreview.addEventListener('mousedown', function(e) {
    e.preventDefault();
    showInlinePreview();
  });
  document.addEventListener('mouseup', function() {
    if (previewActive) hideInlinePreview();
  });

  // è§¸æ§ï¼šæŒ‰ä¸‹é¡¯ç¤ºï¼Œé¬†é–‹éš±è—
  btnPreview.addEventListener('touchstart', function(e) {
    e.preventDefault();
    showInlinePreview();
  }, { passive: false });
  btnPreview.addEventListener('touchend', function(e) {
    e.preventDefault();
    hideInlinePreview();
  }, { passive: false });
  btnPreview.addEventListener('touchcancel', function() {
    hideInlinePreview();
  });

  function showInlinePreview() {
    previewActive = true;
    previewFull.src = imageDataURL;
    inlinePreview.classList.add('show');
  }

  function hideInlinePreview() {
    previewActive = false;
    inlinePreview.classList.remove('show');
  }

  // ===== å›é¦–é  =====
  btnRestart.addEventListener('click', function() {
    resetTimer();
    gameActive = false;
    selectedIndex = null;
    screenGame.style.display = 'none';
    screenUpload.style.display = 'flex';
  });

  // ===== å®Œæˆå¾ŒæŒ‰éˆ• =====
  btnPlayAgain.addEventListener('click', async function() {
    completeOverlay.classList.remove('show');
    resetTimer();
    gameActive = true;
    timerStarted = false;
    moveCount = 0;
    selectedIndex = null;
    await buildPuzzle();
  });

  btnNewImage.addEventListener('click', function() {
    completeOverlay.classList.remove('show');
    screenGame.style.display = 'none';
    screenUpload.style.display = 'flex';

    uploadedImage = null;
    imageDataURL = null;
    uploadZone.classList.remove('has-image');
    const existing = uploadZone.querySelector('.preview-img');
    if (existing) existing.remove();
    uploadIcon.style.display = '';
    uploadText.style.display = '';
    btnStart.classList.remove('ready');
    fileInput.value = '';

    resetTimer();
  });

})();
</script>
</body>
</html>
